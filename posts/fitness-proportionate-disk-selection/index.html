<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet href=/screen.css><title>Fitness Proportionate Disk Selection â€” George Sudarkoff</title></head><body><div id=contents><header class=menu><nav class=nav><ul class=nav-menu><li class=nav-item><a href=/>Home</a>&nbsp;&#9900;&nbsp;</li><li class=nav-item><a href=/posts>Articles</a>&nbsp;&#9900;&nbsp;</li><li class=nav-item><a href=/tags>Tags</a></li></ul></nav></header><section id=main><h1 id=title>Fitness Proportionate Disk Selection</h1><div><article id=content><p><em>This is a proposal I made for improving the disk selection algorithm of a distributed file storage system.</em></p><h2 id=current-disk-selection-algorithm>Current Disk Selection Algorithm</h2><p>The current algorithm randomly selects a disk among the top N percent and assigns it to a given equivalence class. This strategy is suboptimal for a couple of reasons:</p><ol><li>Even when there&rsquo;s a great variability of fitness values among the top N percent of the disks, the most suitable disks will have the same probability of being selected as the least suitable disks, thus leading to unbalanced placement. Simply decreasing the value of N is not sufficient to resolve the problem, as it is always possible to have a situation when the fitness variability is great regardless of how small the N is.</li><li>When nearly all disks in the pool have similar fitness values, they all deserve equal chance, yet only the top N percent will be considered. It&rsquo;s tempting to assume that the next round of placements will favor a different set of disks. But the selection of the next eligible set is determined by the weights that each fitness parameter is assigned. And it is possible that the same group of disks will be used for placement for a while, thus, once again, leading to unbalanced placement.</li></ol><p>Undoubtedly, we would like to preserve some randomness in the selection algorithm to minimize the chances of overwhelming the same disks and nodes with placements and IO. But for reasons stated above, a fitness proportionate selection algorithm is more desirable.</p><h2 id=proposed-algorithm>Proposed Algorithm</h2><p>The proposed algorithm is based on a frequently used method of selecting individuals based on their fitness in genetic and evolutionary algorithms. Typically, a Roulette-wheel selection algorithms is used. Imagine a Roulette wheel in a casino, with a proportion of the wheel assigned to each individual based on their fitness value. Spinning the wheel will result in a particular individual being selected with the probability Pi equal to the fitness of the individual Fi divided by the sum of fitness values for the entire population Sum(Fj), j=1:N. The higher the fitness of the individual, the higher the probability of it being selected. The weaker individuals still have a chance of surviving the selection process, thus preserving a degree of randomness.</p><p>A typical Roulette-wheel algorithm implementation has the complexity between O(N) and O(log N) depending on the search strategy used. But in May 2011, Adam Lipowski and Dorota Lipowska proposed an algorithm (arXiv:1109.3627v2 [cs.NE]) that has the complexity of O(1) and is based on stochastic acceptance instead of searching. Below is a brief description of the algorithm:</p><ol><li>Randomly select one of the disks with uniform probability (without considering its fitness).</li><li>With probability Fi/Fmax, where Fmax is the maximal fitness in the population, the selection is accepted. Otherwise, repeat from step 1.</li></ol><p>Algorithm implementation in pseudocode:</p><pre><code>accepted = False
while (not accepted)
    random(r)                      // random number 0&lt;r&lt;1
    k = int(r*n)                   // k = 0, 1, 2,..., n-1
    random(r)
    if (r &lt; weight(k)/MAX) then    // MAX - maximum of weights
        accepted = True
    end if
end while
</code></pre></article></div></section><aside id=meta><div><section><div id=post-date>May 1, 2013 | 507 Words</div></section><ul id=tags><li><a href=https://george.sudarkoff.com/tags/programming>programming</a></li></ul></div><div><a class=previous href=https://george.sudarkoff.com/posts/climbing-lessons/>Rock climbing lessons</a>
<a class=next href=https://george.sudarkoff.com/posts/key-git-concepts/>Key Git concepts</a></div></aside><div id=footer><hr><div><a href=https://sudarkoff.com><img alt=Coaching src=/img/gs-logo.svg></a>&nbsp;
<a href=https://sudarkoff.blog><img alt=Blog src=/img/substack.svg></a>&nbsp;
<a href=https://linkedin.com/in/sudarkoff><img alt=LinkedIn src=/img/linkedin.svg></a>&nbsp;
<a href=https://hachyderm.io/@sudarkoff rel=me><img alt=Mastodon src=/img/mastodon.svg></a>&nbsp;
<a href=https://github.com/sudarkoff><img alt=GitHub src=/img/github.svg></a></div><div><img alt="pages workflow status" src=https://github.com/sudarkoff/sudarkoff.github.com/actions/workflows/gh-pages.yml/badge.svg>
<img alt="build-deployment workflow status" src=https://github.com/sudarkoff/sudarkoff.github.com/actions/workflows/pages/pages-build-deployment/badge.svg></div><div>George Sudarkoff &copy; 1987-2023</div></div></div></body></html>