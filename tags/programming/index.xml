<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on George Sudarkoff</title><link>https://george.sudarkoff.com/tags/programming/</link><description>Recent content in programming on George Sudarkoff</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 15 Sep 2014 12:00:00 -0800</lastBuildDate><atom:link href="https://george.sudarkoff.com/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Scripting versus automation</title><link>https://george.sudarkoff.com/posts/scripting-vs-automation/</link><pubDate>Mon, 15 Sep 2014 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/scripting-vs-automation/</guid><description>This was originally shared with the engineering org of a company I worked for at the time. It&amp;rsquo;s my stream of consciousness about the type of system my team was building at the time. Reproducing here without modifications, enjoy the chaos of my unedited remblings.
Team,
It became clear to me in the last few days that there&amp;rsquo;s not enough clarity about what we&amp;rsquo;re trying to build.
We keep talking about relatively small and specific things, but we never discuss the philosophy behind it all.</description></item><item><title>Key Git concepts</title><link>https://george.sudarkoff.com/posts/key-git-concepts/</link><pubDate>Thu, 23 May 2013 20:46:53 -0800</pubDate><guid>https://george.sudarkoff.com/posts/key-git-concepts/</guid><description>Understanding a few key concepts will help you make sense of how Git works and how to use it effectively.
Full history With Git, every repository contains a full copy of the project history, and no repository is inherently more important than any other.
Content-addressable Git stores content in files with names that are 40-hexdigit (160-bit) SHA1 hashes. This has some interesting implications. It means for example that Git will never store the same data twice within a repository because identical data would have identical SHA1 hashes and therefore be stored in the same file.</description></item><item><title>Fitness Proportionate Disk Selection</title><link>https://george.sudarkoff.com/posts/fitness-proportionate-disk-selection/</link><pubDate>Wed, 01 May 2013 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/fitness-proportionate-disk-selection/</guid><description>This is a proposal I made for improving the disk selection algorithm of a distributed file storage system.
Current Disk Selection Algorithm The current algorithm randomly selects a disk among the top N percent and assigns it to a given equivalence class. This strategy is suboptimal for a couple of reasons:
Even when there&amp;rsquo;s a great variability of fitness values among the top N percent of the disks, the most suitable disks will have the same probability of being selected as the least suitable disks, thus leading to unbalanced placement.</description></item><item><title>Programmer's Productivity</title><link>https://george.sudarkoff.com/posts/programmer-productivity/</link><pubDate>Thu, 18 Dec 2003 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/programmer-productivity/</guid><description>A meditative piece in which I explore the notion of productivity as applied to the craft of a software developer (and other such crap).
Yesterday I spent twelve hours hunting down a most bizarre bug. I flipped through literally thousands of lines of code, I set dozens of breakpoints only to realize that those places were being hit hundreds of times, and it is virtually impossible to debug it that way.</description></item></channel></rss>