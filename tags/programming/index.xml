<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on George Sudarkoff</title><link>https://george.sudarkoff.com/tags/programming/</link><description>Recent content in Programming on George Sudarkoff</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 10 Feb 2016 12:00:00 -0800</lastBuildDate><atom:link href="https://george.sudarkoff.com/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Distributed Ops for Distributed Apps</title><link>https://george.sudarkoff.com/posts/distributed-ops-proposal/</link><pubDate>Wed, 10 Feb 2016 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/distributed-ops-proposal/</guid><description>&lt;p>&lt;em>My proposal for a talk I delivered at Velocity Amsterdam, 2016. Slides are included at the bottom of the page. For the full transcript of the talk, visit &lt;a href="https://sudarkoff.blog/p/distributed-ops-for-distributed-apps">https://sudarkoff.blog/p/distributed-ops-for-distributed-apps&lt;/a> (paid subscription, free trial available).&lt;/em>&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>In the world of microservices, when things are moving fast and constantly breaking, the accepted wisdom is that teams must own the whole stack and operate their services themselves. But how much stack is &amp;ldquo;the whole stack&amp;rdquo;? How do we ensure that operational standards are consistent across the organization? What&amp;rsquo;s the right balance between consistent standards and the ability to move fast?&lt;/p></description></item><item><title>Scripting versus automation</title><link>https://george.sudarkoff.com/posts/scripting-vs-automation/</link><pubDate>Mon, 15 Sep 2014 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/scripting-vs-automation/</guid><description>&lt;p>&lt;em>This was originally shared with the engineering org of a company I worked for at the time. It&amp;rsquo;s my stream of consciousness about the type of system my team was building at the time. Reproducing here without modifications, enjoy the chaos of my unedited remblings.&lt;/em>&lt;/p>
&lt;p>Team,&lt;/p>
&lt;p>It became clear to me in the last few days that there&amp;rsquo;s not enough clarity about what we&amp;rsquo;re trying to build.&lt;/p>
&lt;p>We keep talking about relatively small and specific things, but we never discuss the philosophy behind it all. What type of system are we building? Can&amp;rsquo;t we just install Puppet and Terraform and call it done? And focus instead on something more glamorous than spinning VMs?&lt;/p></description></item><item><title>Key Git concepts</title><link>https://george.sudarkoff.com/posts/key-git-concepts/</link><pubDate>Thu, 23 May 2013 20:46:53 -0800</pubDate><guid>https://george.sudarkoff.com/posts/key-git-concepts/</guid><description>&lt;p>Understanding a few key concepts will help you make sense of how Git works and how to use it effectively.&lt;/p>
&lt;h2 id="full-history">Full history&lt;/h2>
&lt;p>With Git, every repository contains a full copy of the project history, and no repository is inherently more important than any other.&lt;/p>
&lt;h2 id="content-addressable">Content-addressable&lt;/h2>
&lt;p>Git stores content in files with names that are 40-hexdigit (160-bit) SHA1 hashes. This has some interesting implications. It means for example that Git will never store the same data twice within a repository because identical data would have identical SHA1 hashes and therefore be stored in the same file. It also means that the contents of a Git object will never change because that would change the name the object is stored under.&lt;/p></description></item><item><title>Fitness Proportionate Disk Selection</title><link>https://george.sudarkoff.com/posts/fitness-proportionate-disk-selection/</link><pubDate>Wed, 01 May 2013 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/fitness-proportionate-disk-selection/</guid><description>&lt;p>&lt;em>This is a proposal I made for improving the disk selection algorithm of a distributed file storage system.&lt;/em>&lt;/p>
&lt;h2 id="current-disk-selection-algorithm">Current Disk Selection Algorithm&lt;/h2>
&lt;p>The current algorithm randomly selects a disk among the top N percent and assigns it to a given equivalence class. This strategy is suboptimal for a couple of reasons:&lt;/p>
&lt;ol>
&lt;li>Even when there&amp;rsquo;s a great variability of fitness values among the top N percent of the disks, the most suitable disks will have the same probability of being selected as the least suitable disks, thus leading to unbalanced placement. Simply decreasing the value of N is not sufficient to resolve the problem, as it is always possible to have a situation when the fitness variability is great regardless of how small the N is.&lt;/li>
&lt;li>When nearly all disks in the pool have similar fitness values, they all deserve equal chance, yet only the top N percent will be considered. It&amp;rsquo;s tempting to assume that the next round of placements will favor a different set of disks. But the selection of the next eligible set is determined by the weights that each fitness parameter is assigned. And it is possible that the same group of disks will be used for placement for a while, thus, once again, leading to unbalanced placement.&lt;/li>
&lt;/ol>
&lt;p>Undoubtedly, we would like to preserve some randomness in the selection algorithm to minimize the chances of overwhelming the same disks and nodes with placements and IO. But for reasons stated above, a fitness proportionate selection algorithm is more desirable.&lt;/p></description></item><item><title>Palm OS is dead</title><link>https://george.sudarkoff.com/posts/palmos-is-dead/</link><pubDate>Mon, 15 Nov 2004 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/palmos-is-dead/</guid><description>&lt;p>I was cleaning up the address book on my PDA the other day when I suddenly realized that Palm OS is going to die pretty soon! Yes, I think its days are counted and here&amp;rsquo;s why.&lt;/p>
&lt;p>Programming for the Palm OS platform has a very distinct &amp;ldquo;embedded&amp;rdquo; smell to it. Memory management is a mess, supporting different screen resolutions is a major pain in the butt, and instead of a real file system developers have to deal with this stupid notion that everything is a database. There might have been reasons for it a few years ago but not anymore. And Palm fails to recognize this fact and deal with it appropriately.&lt;/p></description></item><item><title>Programmer's Productivity</title><link>https://george.sudarkoff.com/posts/programmer-productivity/</link><pubDate>Thu, 18 Dec 2003 12:00:00 -0800</pubDate><guid>https://george.sudarkoff.com/posts/programmer-productivity/</guid><description>&lt;p>&lt;em>A meditative piece in which I explore the notion of productivity as applied to the craft of a software developer (and other such crap).&lt;/em>&lt;/p>
&lt;p>Yesterday I spent twelve hours hunting down a most bizarre bug. I flipped through literally thousands of lines of code, I set dozens of breakpoints only to realize that those places were being hit hundreds of times, and it is virtually impossible to debug it that way. I tried everything I could think of, but nothing helped and by the end of the day I was totally exhausted and pretty much ready to choke somebody.&lt;/p></description></item></channel></rss>